[["index.html", "Using the DataDictionary template and the exceldata package 1 Workflow and Biostatistics", " Using the DataDictionary template and the exceldata package 1 Workflow and Biostatistics The DataDictionary0.4.xlsm template (click here for download) contains a DataDictionary sheet and macros to create and format a corresponding DataEntry sheet to facilitate low-level data cleaning and data checking. The exceldata package contains functions for processing Excel files created with the DataDictionary0.4.xlsm template. Integration of the Excel Data Dictionary and the excelData package "],["the-datadictionary-xlsm-file.html", "2 The DataDictionary.xlsm file", " 2 The DataDictionary.xlsm file The purpose of the DataDictionary is to facilitate high-quality data entry. This is achieved by pairing dictionary sheets, which contain information about the type of data with data entry sheets that store the actual data. Even if the data are already entered, the user can create a dictionary and a data entry table and then copy existing data into the table for error highlighting. Workflow of the DataDictionary0.4.xlsm template "],["data-dictionary.html", "2.1 Data Dictionary", " 2.1 Data Dictionary Example of a DataDictionary A user begins by specifying the name, type and allowed range (or values) for each variable. They then create a data entry sheet, by clicking the Create Data Entry Sheet button, which runs a macro to check that the dictionary is complete before generating a data entry sheet with data validation rules and conditional formatting. "],["variable-types.html", "2.2 Variable Types", " 2.2 Variable Types There are seven allowed types of variables: calculated for variables where users specify calculations to be performed (age groups, overall survival) category for variables which can take only pre-specified values character for variables such as the id, or any variable not to be analysed codes for variables where short forms are entered (ie 1=male, 2=female) date for all dates integer for values which can take only whole numbers (ECOG score) numeric for all other numeric values For the date, integer and numeric types the user must specify both a minimum and a maximum value. The minimum and maximum values can be numeric, the names of other variables in the data (if you want to make sure death is after diagnosis) or, for date types, today can be used to allow all dates up to the time of entry. For the codes and category variables the user needs to specify the allowed categories, or the codes, in the order they would like them presented. If they struggle with this for data that has already been entered, then the UNIQUE function in Excel may be of use to them, it will list all the unique variables in a range. Once the dictionary is complete clicking the the Create Data Entry Sheet button will create the data entry table. If the user wishes to change any of the ranges or codes after entering data then they can change the dictionary and click Re-format Exising Sheet to update the validaion rules. If code or category variables are present then a _codes_ sheet will be created to contain the allowed values for data validation. This sheet contains the same name as the data entry sheet, suffixed by codes. This sheet is hidden from the user. "],["data-entry.html", "2.3 Data Entry", " 2.3 Data Entry A Data Entry Table The data entry table contains data validation rules (with prompts) and conditional formatting to highlight cells that fall outside the allowed range of the variable. Users can not enter data outside the allowed range, but they can copy it in from another source. If a user performs a regular paste (Ctrl+V) then the validation and formatting will be over-written. If this happens, then users should click the Re-format Existing Sheet button on the data dictionary sheet. This will re-read all the values in the dictionary and re-apply formatting to the data entry sheet. This is also useful if the user changes the ranges of variables. Once the data entry is complete, the user should click Re-format Existing Sheet to ensure all formats are up to date and all values are checked before sending to the Biostatistics department. Workflow of the DataDictionary.xlsm file "],["multiple-data-sheets.html", "2.4 Multiple Data Sheets", " 2.4 Multiple Data Sheets If the user wishes to have multiple data sheets (for static data vs assessment data) then multiple data dictionaries can be used. The user simply creates a copy of the DataDictionary sheet and creates a different data entry sheet. It will be obvious which dictionaries belong with which data entry sheets by looking at the variables. A workbook with multiple sheets "],["the-exceldata-package.html", "3 The exceldata package", " 3 The exceldata package The exceldata package is a small companion to the DataDictionary workbook. The purpose is to read in the data dictionary and the data entry sheets and then to perform range checks on all the variables. The DataDictionary file does not prevent data entry errors, users can still copy and paste bad values into the sheet. Workflow of the exceldata package "],["import-the-data-dictionary.html", "3.1 Import the Data Dictionary", " 3.1 Import the Data Dictionary The readDataDict function will import the dictionary file. This is slightly more useful than just using readxl::read_excel because checks will be performed to ensure the dictionary is complete and dates will be converted to easy to read text strings. The file and sheetname must be specified. Optional Arguments: colnames Column names of the DataDictionary, defaults to those used in the Excel template range allows a specified range of the sheet to be imported (ie range = A1:F10) origin enables the origin of Excel dates to be set (defaults to 30 December 1899) !readDataDict must be run before readExcelData "],["import-the-data.html", "3.2 Import the Data", " 3.2 Import the Data The readExcelData function will import the data, using the specifications provided in the data dictionary. Again, this should be slightly more useful than a readxl::read_excel because: dates will be imported nicely variables not in the data dictionary will be removed there is an option to store any import warnings, which may be useful to send to the user the data can be read in strictly, setting all values that fall outside the allowed range to NA (This can be useful if users insist on using missing value codes) The file and sheetname, as well as the object returned by the readDataDict function must be specified. Optional Arguments: range allows a specified range of the sheet to be imported (ie range = A1:AB102) origin enables the origin of Excel dates to be set (defaults to 30 December 1899) saveWarnings will return a list with the data frame and the import warnings (if there are any) setErrorsMissing will set all values out of range to NA but this should only be done after running checkData! "],["perform-checks.html", "3.3 Perform Checks", " 3.3 Perform Checks The checkData function will simply check the data against the data dictionary. This requires the outputs of readDataDict and readExcelData. The checkData function will check for duplicate rows and check that all numeric, integer, date, code and category variables meet the requirements of the data dictionary. It does not check the data types, because these are enforced by the readExcelData function. The outputs from readDataDict and readExcelData are required. Optional Argument: id can be used to indicate the patient identifier (ie id =SubjectID) which will provide errors for each id, instead of by row number checkData returns a list with three elements: a data frame containiny all the errors (rows and columns without errors are removed) a two-column data frame with Variable Names in one column and the location of errors in the second (either row numbers or IDs if provided) a two-column data frame with Row Numbers (or IDs) in one columns and the variable containing errors in the second column. "],["create-factor-variables.html", "3.4 Create Factor Variables", " 3.4 Create Factor Variables The addFactorVariables function will rename all the code and category variables suffixed with _orig (so ecog becomes ecog_orig) and create factor variables using the codes provided in the data dictionary as the factor levels and labels. "]]
